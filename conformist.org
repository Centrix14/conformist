-*- eval: (ispell-change-dictionary "english") -*-

#+title: «Conformist» pattern matching library
#+author: Centrix14
#+startup: overview

* About
Conformist is a pattern matching library, that i started as a part of my future CAS.

** Features
=conformist= provides one main function — =shipper=. This function does two things:
1. It returns =t= if given =data= matching to =pattern=.
2. It returns a /shippered/ list. /Shippered/ list is a list that contains all original data, but it can be one-to-one correlate to =pattern=.

=shipper= is a very flexible buddy. In fact, this function is just a /composer/, it provides general logic. All task-specific things can be changed. For this you must implement all necessary functions by your own and push them into instance of =pattern-system= class.

** Naming
You may be astonished by names, but don't worry, i just have a fancy mood. For example /shipper/ is from nickname of some fans that like to create ridiculous love-lines between characters of some film or book. In fact, =shipper= functions makes it: it tries to connect =pattern= and data.

* Syntax of =shipper=
=shipper= takes pattern as first argument and data for matching as second. Pattern can contain:
1. Placeholders a special /keywords/, that describes type of symbol(s), that must be in the on position of placeholder.
2. Concrete values.

conformist don't have built-in placeholders collection, you can define it on your own.

* =conformist= system
Nothing interesting here at all.

#+begin_src lisp :tangle conformist.asd
  (defsystem "conformist"
    :description "conformist is a pattern matching library"
    :version "0.1"
    :author "Centrix14"
    :license "GNU GPL v3"
    :depends-on (:asdf)
    :components ((:file "src/pattern-system")
                 (:file "src/shipper" :depends-on ("src/pattern-system"))))
#+end_src

* =:conformist= package
Just a package description.

#+begin_src lisp :tangle conformist.lisp
  (defpackage :conformist
    (:use :common-lisp)
    (:export :pattern-system :shipper))
#+end_src

* Pattern system
** Placeholders
Main concept of conformist is a /placeholder/. Placeholder is a _keyword_ that /holds a place/ of some value. Examples: =:symbol :list :string :integer=. Placeholders unite in /patterns/. Example: =a :math-op b= where =a= and =b= is a /concrete values/, =:math-op= — placeholder for mathematical operation (remember that conformist provides only general logic and small standard set of placeholders, =:math-op= is just an example).

** Pattern system itself
Since library provides only general logic of pattern matching (and also a standard solution) it needs a flexible mechanism for pattern system realization. =pattern-system= class stores all functions of such pattern system. It has following members:
- =placeholders-collection= a hashmap where key is a placeholder and value is a list with following structure: =(recognition-predicate is-simple)=. =recognition-predicate= returns =t= if his argument matches placeholder. For example, if placeholder is =:integer= then =recognition-predicate= may be =integerp=. =is-simple= is a logic value where =t= means _simple_ and =nil= means _complex_.

#+begin_src lisp :tangle src/pattern-system.lisp
  (defclass pattern-system ()
    ((placeholders-collection
      :initarg :placeholders-collection
      :initform conformist-collection
      :documentation "Placeholders collection")
   
     (placeholder-predicate
      :type function
      :initarg :placeholder-predicate
      :initform #'placeholderp
      :documentation "Predicate for placeholder recognition")

     (simple-placeholder-predicate
      :type function
      :initarg :simple-placeholder-predicate
      :initform #'simplep
      :documentation "Predicate that recognize simple placeholders")

     (data-to-placeholder-matcher
      :type function
      :initarg :data-to-placeholder-matcher
      :initform #'does-placeholder-matches-data
      :documentation "Function for matching data to given placeholder")

     (single-values-matcher
      :type function
      :initarg :single-values-matcher
      :initform #'does-a-matches-b
      :documentation "Function for matching two single values")

     (complex-placeholder-matcher
      :type function
      :initarg :complex-placeholder-matcher
      :initform #'match-complex-placeholder
      :documentation "Function for matching data to complex placeholder"))
  
    (:documentation "Pattern system contains placeholder collection and collection-specific functions"))
#+end_src

* Examples
** Examples it self
Before we can use matching, we must add placeholders and function for them.

#+begin_src lisp :tangle examples.lisp
  (in-package :conformist-examples)

  (defun skip-one (data index)
    (declare (ignore data))
    (1+ index))

  (defun skip-symbols (data index)
    (format t "index: ~a~%" index)
    (let ((elm (elt data index)))
      (loop while (< index (length data)) do
        (unless (symbolp elm)
          (return-from skip-symbols index))
        (setf elm (elt data index))
        (incf index)))
    (format t "skip: ~a~%" (1- index))
    (1- index))

  (defun add-placeholders ()
    (map nil #'define-placeholder
         (list :symbol :list :symbols)
         (list #'symbolp #'listp #'symbolp)
         (list #'skip-one #'skip-one #'skip-symbols)))

  (defun remove-placeholders ()
    (maphash (lambda (key value)
               (declare (ignore value))
               (remhash key *placeholders*))
             ,*placeholders*))
#+end_src

Current version of =matchp= is very simple. Here is an examples of usage (all of them returns =t=).

#+begin_src lisp :tangle examples.lisp
  (defun test1 ()
    (values
     ;; :list placeholder describes list
     (matchp '(:list) '((1 2 3)))

     ;; :symbol placeholder describes one symbol
     (matchp '(:symbol) '(a))

     ;; placeholders may be nested
     (matchp '(:symbol (:symbol :list)) '(a (b (c d))))

     ;; you can mix placeholders and values
     (matchp '(a :symbol (b :list c)) '(a / (b (1 2 3) c)))))

  ;; :symbols placeholder describes one or more symbols
  (defun test2 ()
    (matchp '(a :symbols) '(a b c d)))
#+end_src

#+begin_src lisp :tangle examples.lisp
  (defun make-tests ()
    (add-placeholders)
    (test1)
    )
#+end_src

