-*- eval: (ispell-change-dictionary "english") -*-

#+title: «Conformist» pattern matching library
#+author: Centrix14
#+startup: overview

* About
Conformist is a pattern matching library, that i started as a part of my future CAS.

** Features
=conformist= provides one main function — =shipper=. This function does two things:
1. It returns =t= if given =data= matching to =pattern=.
2. It returns a /shippered/ list. /Shippered/ list is a list that contains all original data, but it can be one-to-one correlate to =pattern=.

=shipper= is a very flexible buddy. In fact, this function is just a /composer/, it provides general logic. All task-specific things can be changed. For this you must implement all necessary functions by your own and push them into instance of =pattern-system= class.

** Naming
You may be astonished by names, but don't worry, i just have a fancy mood. For example /shipper/ is from nickname of some fans that like to create ridiculous love-lines between characters of some film or book. In fact, =shipper= functions makes it: it tries to connect =pattern= and data.

* Syntax of =shipper=
=shipper= takes pattern as first argument and data for matching as second. Pattern can contain:
1. Placeholders a special /keywords/, that describes type of symbol(s), that must be in the on position of placeholder.
2. Concrete values.

conformist don't have built-in placeholders collection, you can define it on your own.

* =conformist= system
Nothing interesting here at all.

#+begin_src lisp :tangle conformist.asd
  (defsystem "conformist"
    :description "conformist is a pattern matching library"
    :version "0.1"
    :author "Centrix14"
    :license "GNU GPL v3"
    :depends-on (:asdf)
    :components ((:file "src/pattern-system")
                 (:file "src/util")
                 (:file "src/shipper" :depends-on ("src/pattern-system"
                                                   "src/util"))
                 (:file "src/std-collection" :depends-on ("src/util"))))
#+end_src

* =:conformist= package
Just a package description.

#+begin_src lisp :tangle conformist.lisp
  (defpackage :conformist
    (:use :common-lisp)
    (:export :pattern-system :shipper))
#+end_src

* Pattern system
** Placeholders
Main concept of conformist is a /placeholder/. Placeholder is a _keyword_ that /holds a place/ of some value. Examples: =:symbol :list :string :integer=. Placeholders unite in /patterns/. Example: =a :math-op b= where =a= and =b= is a /concrete values/, =:math-op= — placeholder for mathematical operation (remember that conformist provides only general logic and small standard set of placeholders, =:math-op= is just an example).

** Pattern system itself
Since library provides only general logic of pattern matching (and also a standard solution) it needs a flexible mechanism for pattern system realization. =pattern-system= class stores all functions of such pattern system. It has following definition:
  
#+begin_src lisp :tangle src/pattern-system.lisp
  (defclass pattern-system ()
    ((placeholders-collection
      :initarg :placeholders-collection
      :initform conformist-collection
      :documentation "Placeholders collection")
   
     (placeholder-predicate
      :type function
      :initarg :placeholder-predicate
      :initform #'placeholderp
      :documentation "Predicate for placeholder recognition")

     (simple-placeholder-predicate
      :type function
      :initarg :simple-placeholder-predicate
      :initform #'simplep
      :documentation "Predicate that recognize simple placeholders")

     (data-to-placeholder-matcher
      :type function
      :initarg :data-to-placeholder-matcher
      :initform #'does-placeholder-matches-data
      :documentation "Function for matching data to given placeholder")

     (single-values-matcher
      :type function
      :initarg :single-values-matcher
      :initform #'does-a-matches-b
      :documentation "Function for matching two single values")

     (complex-placeholder-matcher
      :type function
      :initarg :complex-placeholder-matcher
      :initform #'match-complex-placeholder
      :documentation "Function for matching data to complex placeholder"))
  
    (:documentation "Pattern system contains placeholder collection and collection-specific functions"))
#+end_src

*** =placeholders-collection=
=placeholders-collection= a hashmap where key is a placeholder and value is a list with following structure: =(recognition-predicate is-simple)=. =recognition-predicate= returns =t= if his argument matches placeholder. For example, if placeholder is =:integer= then =recognition-predicate= may be =integerp=. =is-simple= is a logic value where =t= means _simple_ and =nil= means _complex_.

As i already said conformist has standard placeholder system. =placeholders-collection= in this system looks this way:
#+begin_src lisp :tangle src/std-collection.lisp
  (create-hash-table conformist-collection nil
                     (:symbol (symbolp t))
                     (:list (listp t))
                     (:symbols (symbolp nil))
                     (:lists (listp nil)))
#+end_src

From this definition (i hope) you can see:
1. I create hash table named =conformist-collection=.
2. Keys in this table are keywords (placeholders).
3. Values is this table is a lists where first element is a predicate and the second element is a simplicity.

For definition of =create-hash-table= please visit [[id:util:create-hash-table][this]] section.

*** =placeholder-predicate=
=placeholder-predicate= is a predicate function that returns =t= if argument is a placeholder in current pattern system.

In standard pattern system this predicate defined this way:
#+begin_src lisp :tangle src/std-collection.lisp
  (defun placeholderp (data pattern-system)
    (with-slots ((collection placeholders-collection)) pattern-system
      (multiple-value-bind (value exists) (gethash data collection)
        (declare (ignore value))
        exists)))
#+end_src

Looks horrible? Maybe, but it not so hard to understand.
1. I get collection placeholders.
2. Then i use =gethash= to search for requested placeholder (=data=).
3. Then i get second returned value (existance) and return it as a result.

*** =simple-placeholder-predicate=
=simple-placeholder-predicate= must be deleted.

*** =data-to-placeholder-matcher=
=data-to-placeholder-matcher= is a function that returns =t= if given argument data matches given placeholder.

Built-in version of this function looks like this:
#+begin_src lisp :tangle src/std-collection.lisp
  (defun does-placeholder-matches-data (placeholder data pattern-system)
    (with-slots ((collection placeholders-collection)) pattern-system
      (funcall (first (gethash placeholder collection)) data)))
#+end_src

It works very simple. As you know, from =placeholders-collection= slot we can extract =recognition-predicate=. So, we extract it and call with given data. That all folks!

*** =single-values-matcher=
=single-values-matcher= is a function that returns =t= if given value =b= matches to =a=.

In std-collection this functionality provides =does-a-matches-b= function:
#+begin_src lisp :tangle src/std-collection.lisp
  (defun does-a-matches-b (a b pattern-system)
    (with-slots (placeholder-predicate data-to-placeholder-matcher) pattern-system
        (if (funcall placeholder-predicate a pattern-system)
            (funcall data-to-placeholder-matcher a b pattern-system)
            (equalp a b))))
#+end_src

This function uses following algorithm:
1. If =a= is a placeholder then try to match placeholder to data using =data-to-placeholder-matcher=.
2. If =a= is just a value then compare =a= and =b=.

*** =complex-placeholder-matcher=
=complex-placeholder-matcher= is a function that matches and groups data to complex placeholder.

This function is kinda simple too:
#+begin_src lisp :tangle src/std-collection.lisp
  (defun match-complex-placeholder (data index edge-placeholder pattern-system)
    (with-slots ((matcher single-values-matcher)) pattern-system
      (loop for i from index to (frontier data)
            while (not
                   (funcall matcher edge-placeholder (elt data i) pattern-system))
            collect (elt data i))))
#+end_src

This function collects values starting and =index= in =data= until it not matches to =edge-placeholder=.

* Utilities
In this section i will describe some utilities.

** =create-hash-table=
:properties:
:id: util:create-hash-table
:end:
=create-hash-table= is a macro that creates variable, stores there new hash table and fills it then.

Definition looks this way:
#+begin_src lisp :tangle src/util.lisp
  (defmacro create-hash-table (name make-args &rest values)
    `(progn
       (defvar ,name (make-hash-table ,@make-args))

       (loop for pair in ',values do
         (setf (gethash (first pair) ,name) (second pair)))))
#+end_src

* Examples
** Examples it self
Before we can use matching, we must add placeholders and function for them.

#+begin_src lisp :tangle examples.lisp
  (in-package :conformist-examples)

  (defun skip-one (data index)
    (declare (ignore data))
    (1+ index))

  (defun skip-symbols (data index)
    (format t "index: ~a~%" index)
    (let ((elm (elt data index)))
      (loop while (< index (length data)) do
        (unless (symbolp elm)
          (return-from skip-symbols index))
        (setf elm (elt data index))
        (incf index)))
    (format t "skip: ~a~%" (1- index))
    (1- index))

  (defun add-placeholders ()
    (map nil #'define-placeholder
         (list :symbol :list :symbols)
         (list #'symbolp #'listp #'symbolp)
         (list #'skip-one #'skip-one #'skip-symbols)))

  (defun remove-placeholders ()
    (maphash (lambda (key value)
               (declare (ignore value))
               (remhash key *placeholders*))
             ,*placeholders*))
#+end_src

Current version of =matchp= is very simple. Here is an examples of usage (all of them returns =t=).

#+begin_src lisp :tangle examples.lisp
  (defun test1 ()
    (values
     ;; :list placeholder describes list
     (matchp '(:list) '((1 2 3)))

     ;; :symbol placeholder describes one symbol
     (matchp '(:symbol) '(a))

     ;; placeholders may be nested
     (matchp '(:symbol (:symbol :list)) '(a (b (c d))))

     ;; you can mix placeholders and values
     (matchp '(a :symbol (b :list c)) '(a / (b (1 2 3) c)))))

  ;; :symbols placeholder describes one or more symbols
  (defun test2 ()
    (matchp '(a :symbols) '(a b c d)))
#+end_src

#+begin_src lisp :tangle examples.lisp
  (defun make-tests ()
    (add-placeholders)
    (test1)
    )
#+end_src

