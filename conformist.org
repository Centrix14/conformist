-*- eval: (ispell-change-dictionary "english") -*-

#+title: «Conformist» pattern matching library
#+author: Centrix14
#+startup: overview

* What is it for?
#+begin_src markdown :tangle README.md
  # Conformist
  Conformist is a pattern matching library, that i started as a part of my CAS.

  # Features
  As a real programmer i don't present realized features, i speaking about my plans.
  1. Pattern matching for S-expression with placeholders, like `:symbol`, `:list` and another.
  2. Flexible system of placeholders.
  3. Pattern grouping (see chapter "thoughts" in org-file).

  # What i have at the time?
  Very simple library, but soon i will expand it.
#+end_src

* Syntax of =matchp
=matchp= takes pattern as first argument and data for matching as second. Pattern can contain:
1. Placeholders a special /keywords/, that describes type of symbol(s), that must be in the on position of placeholder. There are following placeholders:
   - =:symbol= describes one symbol
   - =:list= describes one list
   - =:symbols= describes one or more symbols
   - =:lists= describes one or more lists
   - =:etc= describes one or more symbols or lists
2. Concrete values.

* =conformist= system
Nothing interesting here at all.

#+begin_src lisp :tangle conformist.asd
  (defsystem "conformist"
    :description "conformist is a pattern matching library"
    :version "0.1"
    :author "Centrix14"
    :license "GNU GPL v3"
    :depends-on (:asdf)
    :components ((:file "placeholders")
                 (:file "matching")
                 (:file "util")
                 (:file "conformist" :depends-on ("placeholders"
                                                  "matching"
                                                  "util"))))
#+end_src

* =:conformist= package
Just a package description

#+begin_src lisp :tangle conformist.lisp
  (defpackage :conformist
    (:use :common-lisp)
    (:export :matchp))
#+end_src

* Placeholders
** Basics
As i already said =matchp= works with placeholders. Placeholder has to characteristics:
- Recognition predicate a function that returns =t= if her argument matched specified placeholder.
- Shift function is a function that returns number of elements that must be skipped in given sequence.

Recognition predicate and shift function stored in list that is a value for placeholder key.

#+begin_src lisp :tangle placeholders.lisp
  (in-package :conformist)

  (defvar *placeholders* (make-hash-table :test #'equal))
#+end_src

** Placeholders: create, change and remove
I think that user mustn't work with =*placeholders*= directly, so i give him a corresponding function.

#+begin_src lisp :tangle placeholders.lisp
  (defun define-placeholder (placeholder recognition-predicate shift-function)
    (if (gethash placeholder *placeholders*)
        (format t "You try to redefine an existing placeholder~%")
        (setf (gethash placeholder *placeholders*) (list recognition-predicate
                                                         shift-function))))
#+end_src

Since we can add placeholders, we can remove them. This functionality provided by =remove-placeholder=.

#+begin_src lisp :tangle placeholders.lisp
  (defun remove-placeholder (placeholder)
    (if (gethash placeholder *placeholders*)
        (remhash placeholder *placeholders*)
        (format t "You try to remove unexisting placeholder~%")))
#+end_src

Also we can redefine placeholders, so =redefine-placeholder= do it.

#+begin_src lisp :tangle placeholders.lisp
  (defun redefine-placeholder (placeholder recognition-predicate shift-function)
    (if (gethash placeholder *placeholders*)
        (setf (gethash placeholder *placeholders*) (list recognition-predicate
                                                         shift-function))
        (format t "You try to redefine unexisting placeholder~%")))
#+end_src

** Accessors
All placeholders logic is implemented, but for further work we need some access functions.

First function in this group is a =get-recognition-predicate=, that returns recognition predicate for given placeholder.

#+begin_src lisp :tangle placeholders.lisp
  (defun get-recognition-predicate (placeholder)
    (values (first (gethash placeholder *placeholders*)) placeholder))
#+end_src

Another function is =get-shift-function= and i think there is no need in any other words about it.

#+begin_src lisp :tangle placeholders.lisp
  (defun get-shift-function (placeholder)
    (values (second (gethash placeholder *placeholders*)) placeholder))
#+end_src

** Predicates
=placeholderp= is a predicate that returns =t= if given value is a placeholder.

#+begin_src lisp :tangle placeholders.lisp
  (defun placeholderp (data)
    (if (gethash data *placeholders*)
        t
        nil))
#+end_src

Ok, now we have basics of placeholders and can write a function that compares some data with given placeholder (we suppose that given =placeholder= is a real placeholder).

#+begin_src lisp :tangle placeholders.lisp
  (defun does-placeholder-matches-data (placeholder data)
    (funcall (get-recognition-predicate placeholder) data))
#+end_src

If you ask me, why this code so simple and not flexible, i give an answer: this is a temporary solution, soon i will make it more complicated.

* Matching
** Primitive matching
Well, now we can +take chance on me+ (sorry for ABBA-speaking). Now we can describe matching mechanism. Here, we begin from the most simple function, that returns =t=, if some symbol =a= matches another symbol =b=.

#+begin_src lisp :tangle matching.lisp
  (in-package :conformist)

  (defun does-a-matches-b (a b)
    (if (placeholderp a)
        (does-placeholder-matches-data a b)
      (equal a b)))
#+end_src

As you can see this function uses =does-placeholder-matches-data= function of =a= is a placeholder, or just returns equivalence of symbols.

#+begin_comment
In this function i use =equal= because given data may be lists, and =(eql '(1 2 3) '(1 2 3))= is not =t=.
#+end_comment

** =matchp=: unsafe version
Following code is quite ugly but this version is much faster and more lightweight. It's not the edge of optimization, but closer to it than previous code.

#+begin_src lisp :tangle matching.lisp
  (defun matchp-not-safe (pattern data)
    (let ((pattern-index 0)
          (data-index 0)
          (pattern-len (length pattern))
          (data-len (length data)))
      (loop while (and (< pattern-index pattern-len)
                       (< data-index data-len))
            do
               (let ((pattern-elm (elt pattern pattern-index))
                     (data-elm (elt data data-index)))
                 (if (listp pattern-elm)
                     (unless (matchp-not-safe pattern-elm data-elm)
                       (return-from matchp-not-safe nil))
                     (unless (does-a-matches-b pattern-elm data-elm)
                       (return-from matchp-not-safe nil)))
                 (incf data-index (funcall (get-shift-function pattern-elm)
                                           data
                                           pattern-index))
                 (incf pattern-index)))
      t))
#+end_src

** =matchp=: safe version
At least, i define =matchp= function, as a safe version of unsafe =mathcp=.

#+begin_src lisp :tangle matching.lisp
  (defun matchp (pattern data)
    (if (= (length pattern)
           (length data))
        (matchp-not-safe pattern data)
        nil))
#+end_src

* Utilities
#+begin_src lisp :tangle util.lisp
  (defmacro inc (var &optional (delta 1))
    `(setf ,var (+ ,var ,delta)))
#+end_src

* Examples
Before we can use matching, we must add placeholders and function for them.

#+begin_src lisp :tangle example.lisp
  (defun skip-one (data index)
    (declare (ignore data))
    (declare (ignore index))
    1)

  (map nil #'define-placeholder
       (list :symbol :list)
       (list #'symbolp #'listp)
       (list #'skip-one #'skip-one))
#+end_src

Current version of =matchp= is very simple. Here is an examples of usage (all of them returns =t=).

#+begin_src lisp :tangle example.lisp
  ;; :list placeholder describes list
  (matchp '(:list) '((1 2 3)))

  ;; :symbol placeholder describes one symbol
  (matchp '(:symbol) '(a))

  ;; :etc placeholder describes one and more symbols
  (matchp '(:etc) '(a b c))

  ;; placeholders may be nested
  (matchp '(:symbol (:symbol :list)) '(a (b (c d))))

  ;; you can mix placeholders and values
  (matchp '(a :symbol (b :list c)) '(a / (b (1 2 3) c)))

  (:symbol (:symbol :lists))
  (a (b (1 2 3) (4 5 6)))
#+end_src

* TODO [1/7]
- [X] Make =*placeholders*= hash table
- [ ] Separate system to different files
- [ ] Add error system
- [ ] Add classes
- [ ] Add =:lists=, =:symbols= and =:etc= placeholders
- [ ] Reduce recursion
- [ ] Add grouping

* Thoughts
How grouping must work? Generally, grouping provide a new list, that can be one-to-one matched to given.

Some examples.

#+begin_example
  Pattern:  (:symbol :symbol)
  Data:     (a b)
  Grouping: ((a) (b))

  Pattern:  (:list :list)
  Data:     ((1 2 3) (a b c))
  Grouping: (((1 2 3)) ((a b c)))

  Pattern:  (:symbol :list)
  Data:     (a (1 2 3))
  Grouping: ((a) ((1 2 3)))

  Pattern:  (:symbols)
  Data:     (a b c)
  Grouping: ((a b c))

  Pattern:  (:lists)
  Data:     ((1 2 3) (4 5 6))
  Grouping: (((1 2 3) (4 5 6)))

  Pattern:  (:symbols :lists)
  Data:     (a b c (1 2 3) (4 5 6))
  Grouping: ((a b c) ((1 2 3) (4 5 6)))
#+end_example

